/**
 * Copyright 2017 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ----------------------------------------------------------------------------
 */
'use strict'

const _ = require('lodash')
const db = require('../db')
const users = require('../db/users')
const agents = require('../db/agents')
const auth = require('./auth')
const protos = require('../blockchain/protos')

const { BadRequest, NotAcceptable } = require('./errors')
const {
  awaitServerPubkey,
  getTxnCreator,
  submitTxns,
  encodeTimestampedPayload
} = require('../system/submit_utils')

const secp256k1 = require('sawtooth-sdk/signing/secp256k1')

const sjcl = require('sjcl')
const context = new secp256k1.Secp256k1Context()

const createAdmin = () => {

  const hashPassword = password => {
    const bits = sjcl.hash.sha256.hash(password)
    return sjcl.codec.base64.fromBits(bits)
  }

  let admins = [
    {
      'username': 'administrator',
      'name': 'Administrator',
      'email': 'admin@admin.admin',
      'nif': '100763801',
      'password': 'administrator',
      'role': 'admin',
      'privateKey': '8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918',//generated by 'admin' word
      'active': 1
    }]

  let createTxn = null
  return protos.compile()
    .then(awaitServerPubkey)
    .then(batcherPublicKey => {
      const txnCreators = {}

      createTxn = (privateKey, payload) => {
        if (!txnCreators[privateKey]) {
          txnCreators[privateKey] = getTxnCreator(privateKey, batcherPublicKey)
        }
        return txnCreators[privateKey](payload)
      }
    })

    // Create Agents
    .then(() => {
      console.log('Creating Agents . . .')
      const agentAdditions = admins.map(agent => {
        return createTxn(agent.privateKey, encodeTimestampedPayload({
          action: protos.SCPayload.Action.CREATE_AGENT,
          createAgent: protos.CreateAgentAction.create({ name: agent.name })
        }))
      })
      return submitTxns(agentAdditions)
    }).catch(reason => console.log("Admin was here"))

    // Create Users
    .then(() => {
      console.log('Creating Users . . .')
      const userRequests = admins.map(agent => {
        const user = _.omit(agent, 'name', 'privateKey', 'hashedPassword')
        user.password = hashPassword(agent.password)

        user.publicKey = context.getPublicKey(secp256k1.Secp256k1PrivateKey.fromHex(agent.privateKey)).asHex()

        user.encryptedKey = sjcl.encrypt(agent.password, agent.privateKey)

        return Promise.resolve()
          .then(() => {
            return agents.fetch(user.publicKey, null)
              .catch(() => {
                throw new BadRequest('Public key must match an Agent on blockchain')
              })
          })
          .then(() => auth.hashPassword(user.password))
          .then(hashed => {
            return users.insert(_.assign({}, user, {
              password: hashed,
              active: 1
            }))
              .catch(err => { throw new BadRequest(err.message) })
          })
          .then(() => auth.createToken(user.publicKey))
          .then(token => ({
            authorization: token,
            encryptedKey: user.encryptedKey || null,
            user: user
          })).catch((e) => {})
      })

      return Promise.all(userRequests)
    })
}

const create = user => {
  return Promise.resolve()
    .then(() => {
      return agents.fetch(user.publicKey, null)
        .catch(() => {
          throw new BadRequest('Public key must match an Agent on blockchain')
        })
    })
    .then(() => auth.hashPassword(user.password))
    .then(hashed => {
      return users.insert(_.assign({}, user, {
        password: hashed,
        active: 0
      }))
        .catch(err => { throw new BadRequest(err.message) })
    })
    .then(() => auth.createToken(user.publicKey))
    .then(token => ({
      authorization: token,
      encryptedKey: user.encryptedKey || null,
      user: user
    }))
}

const update = (changes, { authedKey }) => {
  return Promise.resolve()
    .then(() => {
      if (changes.password) {
        return auth.hashPassword(changes.password)
          .then(hashed => _.set(changes, 'password', hashed))
      }
      return changes
    })
    .then(finalChanges => users.update(authedKey, finalChanges))
    .then(updated => _.omit(updated, 'password'))
    .catch(error => {
      console.log('\n\n\ API USERS \n  ' + error.message)
      throw new NotAcceptable(error.message)
    })
}

const fetch = (publicKey) => users.fetch(publicKey)

module.exports = {
  create,
  update,
  fetch,
  createAdmin
}
